
<!DOCTYPE unspecified PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<style>
			.code		{background-color: #f6f9f6;}
            .inCode		{font-family:"Courier New", Courier, monospace}
			.comment	{color:green}
			.module_name{color:blue}
			h1			{color:darkblue}
			h2			{color:darkblue}
		</style>	
	
	</head>
	<body>
		<h1>Data Processing Units (DPUs)</h1>		
			
		<h2>Types of DPUs</h2>
        <div>The application distinguished three types of DPUs: 
        <ul>
            <li>Extractor - DPU which extract data from some source. This DPU type has only outputs.</li>
            <li>Transformer - DPU which transform input data into output data. This DPU has inputs as well as outputs.</li>
            <li>Loader - DPU which save into DB/File/etc.. This DPU has only inputs. </li>
         </ul>   
        </div>
	
		<h2>Logging the DPU's activity</h2>
		<div>Every DPU should log extensively. To log in your DPU, use slf4j. 
			The log for each DPU is stored and accessible to the user by the graphical user interface of the application. 
			Using sl4j is simple. If you are not familiar with sl4j	the following example shows the basics.<br/>
			<div class="code"> <pre> <code>
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DPUTemplate  {
	private Logger = LoggerFactory.getLogger(DPUTemplate.class);
...
			</code> </pre> </div>
			Just remember to replace DPUTemplate with your class's name. Then when you want to log something just call:<br/>
			<div class="code"> <pre> <code>logger.debug("Some message .. ");</code> </pre> </div>
		</div>
	
		<h2 id="secConfigurationConcept">Configuration concept</h2>
		<div>Each DPU has possibility to store configuration that can configure DPU execution. User can edit the configuration
			through the configuration dialog which is also provided by DPU implementation. <br/> 
			
			The configuration is accessible as member variabl.The configuration class must implement interface
			<div class="code"> <pre> <code>
interface cz.cuni.xrg.intlib.commons.configuration.DPUConfigObject {} .. </code> </pre> </div> 
			which is located in commons.
			</div>
	
		<h2>DataUnit containers</h2>
		<div>Data between DPUs are passed in containers that are called DataUnits. The DataUnit from the programmer's point of view is an interface
			that does not offer any usable functionality. For practical use, more specific interface is provided. Currently only one interface 
			is available: <i>RDFDataRepository</i>. The DataUnit (ie. RDFDataRepository) can't be created directly. 
			To create DataUnit use <span class="inCode">DataUnitFactory</span>, which is accessible via <span class="inCode">Context</span>.</div>
					
		<h3>DataUnit - RDFDataRepository</h3>
		The RDFDataRepository is RDF focused implementation of DataUnit. Let's name few importat function for work with RDFDataRepository (to store RDF data being prepared by the DPU).
		<ul>
			<!--<li><b>addOutputDataUnit</b> - Associate output data unit with the context of the </li>-->
			<li><b>transformUsingSPARQL</b> - Transform data in repository using given SPARQL query.</li>
			<li><b>addTripleToRepository</b> - Add given triple into repository.</li>
			<li><b>extractRDFfromXMLFileToRepository</b> - Read data from the given file and add them to the repository.</li>
		</ul> For more information about the methods please refer to the <span class="inCode">RDFDataRepository</span> documentation. 
				
                        
                <h2 id="context">Context</h2>
		<div>Each DPU has execution context. It's main interface is <span class="inCode">ProcessingContext</span> located in commons. The DPU itself (extractor/transformer/loader)
			uses more special type of <span class="inCode">Context</span> ie. <span class="inCode">ExtractContext</span>, <span class="inCode">TransformContext</span> or <span class="inCode">LoadContext</span>. 
			The context provide ability to send messages (events) that are stored and accessible to the user. <br/>
			Context also manages access to the input/output DataUnits. The following example demonstrate this functionality for transformer: <br/>
			<div class="code"> <pre> <code>
			
<span class="comment">// get first input as RDFDataRepository</span>
DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
RDFDataRepository intputRepository = dataUnitList.getFirst();

<span class="comment">// create output RDFDataRepository</span>
RDFDataRepository outputRepository = 
		(RDFDataRepository) context.addOutputDataUnit(DataUnitType.RDF, "output_name");
                
			</code> </pre> </div>
		</div>
	
		<h1>Tutorial - Creation of Custom DPUs</h2>
		<div>This tutorial will guide you through the process of the new data processing unit (DPU) creation. </div>
		
		
		<div>
      It the following sections we will go through the files prepared in the DPU template project (which may be obtained from <a href="https://github.com/mff-uk/intlib"> Github project site</a>, master branch, folder "module/DPU_template"), from which you may derive your DPU implementation. You may start by copying the "module/DPU_template" folder and opening it in, e.g., Netbeans. You can also be inspired by the existing DPU implementations in the folder "module".
      </div>
      
      <div>
      The template DPU contains 4 important files, which are typically needed when new DPU is created. For each file, we explain in the following sections its purpose and list the mandatory and optional changes (called TODOs) that need to be done to implement DPU.</div>
        <div>For each DPU, you have to:
        <ul>
        	<li>adjust pom.xml containing basic metadata about the DPU implementation</li>
        	<li>define configuration class which implements <span class="inCode">Config</span> interface and holds configuration of the DPU</li>
        	<li>define the configuration dialog, which may be used by users of your DPU to set up the configuration of your DPU and extends <span class="inCode">AbstractConfigDialog&lt;Config&gt;</span>. The configuration obtained from the dialog is stored to the configuration class</li>
        	<li>implement the class which executes the DPU - it contains the main functionality of the DPU and the functionality may be influenced by the configuration class</li>
        </ul> </div>

		<h3>pom.xml</h3>
		<div>The pom.xml file contains Maven configuration. If you are not familiar with Maven then just ignore everything except of several lines containing "TODOs", which needs your attention. 
			TODOs have assigned number to make it easy to follow. In next few lines we go through all of them and give brief comment to each of them:
			<ul>
				<li><b>TODO 1. module_name: </b>The Maven's artifact's ID should be provided here. 
					Maven uses this name to identify the output module (jar) filename.  
					This value should contains only a-z, A-Z, 0-9 and _ as whitespace. 
                                    </li>				
				<li><b>TODO 2. DPU version: </b> In most common scenarios you can leave the default value here. This value is stored in manifest.mf file as "version of DPU". 
					It correspond with Bundle-Version in manifest.mf. </li>
				<li><b>TODO 3. DPU description: </b> DPU's description is visible to the users. Provide all necessary information about your intended DPU usage here. 
					Provide contact details on the author of the DPU.</li>
				<li><b>TODO 4. DPU package: </b> Specify the root (longest common) package. If you use just one package, use it's name.</li>
				<li><b>TODO 5. DPU's <span class="module_name">main_class_name</span>: </b> Fill the DPU main class name. 
					The main class must be placed in package specified in the previous step.</li>
			</ul>
			Here you can also add dependencies to other jar files. Do not add them elsewhere
			as they may not be visible to the Maven.
		</div>

		<h3>DPUTemplate.java</h3>
		<div>The DPU's main class. The name of the class and file must be the same as <span class="module_name">main_class_name</span>. 
			Thus, rename the file and class in it according to <span class="module_name">main_class_name</span>.
			As in pom.xml the template file contains "TODOs", places which requires your attention:
			<ul>
				<li><b>TODO 1.</b> First of all we need to change the extended base class of the DPU. 
					The following super classes are available: 
					<ul>
						<li><b>Extract</b> - Use if you implement new Extractor</li>
						<li><b>Transform</b> - Use if you implement new Transformer </li>
						<li><b>Load</b> - Use if you implement new Loader</li>
					</ul> 
					Each of these interfaces contains unique method that has to be implemented. We return to this later.</li>
				<li><b>TODO 2.</b> Based on implemented interface (selected in TODO 1.) you have to provide implementation
				  	of one corresponding method required by that interface:
				  	<ul>
				  		<li><b>public extract(ExtractContext context) throws ExtractException</b> for <b>Extrac</b></li>				  			
				  		<li><b>public void transform(TransformContext context) throws TransformException</b> for <b>Transfor</b></li>
				  		<li><b>public void load(LoadContext context) throws LoadException</b> for <b>Load</b></li>
				  	</ul> 
				  	In this method the functionality of the DPU should be implemented. All important data needed is passed to the method as <a href="#context">Context</a>. 
				
                                    <br/><br/>
                                      Sample transform() method for simple SPARQL transformer executing the given SPARQL query:
                               <div class="code"> <pre> <code>
<span class="comment">// transform method which has to be implemented by DPU - transformer</span>
public void transform(TransformContext context) throws TransformException, DataUnitCreateException {
			
    <span class="comment">// get first input as RDFDataRepository</span>
    DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
    RDFDataRepository intputRepository = dataUnitList.getFirst();
	    
    <span class="comment">// create output </span>
    RDFDataRepository outputRepository = 
                    (RDFDataRepository) context.addOutputDataUnit(DataUnitType.RDF);
     
    <span class="comment">// query to be executed (obtained from the dialog) </span>            
    String updateQuery = config.getQuery();
                
    <span class="comment">// copies all data from input RDFDataRepository to output RDFDataRepository and transforms </span>
    intputRepository.copyAllDataToTargetRepository(outputRepository);
    outputRepository.transformUsingSPARQL(updateQuery);
}

			</code> </pre> </div>
				
				</li>
			</ul>
		</div>
		
		<h3>DPUTemplateDialog.java</h3>
		<div>This file contains implementation of DPU's configuration dialog. 
			The DPU's configuration dialog is implemented as a <a href="www.vaadin.com">Vaadin</a> component. The dialog
			class must extends abstract class
			<div class="code"> <pre> <code> BaseConfigDialog&lt;Config&gt; </code> </pre> </div>
			</div>
			
		<h3>DPUTemplateConfig.java</h3>
		<div>This file contains template for DPU's configuration. It represents an object holding configuration needed by the DPU. The class must implement interface
			<div class="code"> <pre> <code> cz.cuni.xrg.intlib.commons.configuration.DPUConfigObject</code> </pre> Put your configuration 
			variables inside this class. You can then access it from DPUTemplate class through the atribut <span class="inCode">config</span>. </div>
		
		
		<h3>Compile DPU project</h3>
		To compile DPU project into output jar (bundle) file use <b>mvn install</b> command.
		
		<h3>DPU-jar deploy</h3>
		The DPU jar file can be added to the Intlib through the web-application on page DPU.
		The same file cannot be added twice, even under different names. These may
		result into complication with using one of the DPU in Intlib. To load new version of
		the jar-file please change it's version in pom.xml or simplz revrite the old one 
		in {project_path}\dpu.
		
	</body>
</html>
 

