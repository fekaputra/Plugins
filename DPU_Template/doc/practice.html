<!DOCTYPE unspecified PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		
	
		<h2>DPU Creation Tutorial </h2>
		<p>This tutorial will guide you through the process of the DPU's main class creation, implementation of the DPU's configuration dialog (if needed) and creation of the OSGi bundle with the DPU, so that DPU may be loaded to ODCLeanStore. </p>
		
		<p>
		It the following sections we will 
		go through the files prepared in the DPU template project 
		(which may be obtained from <a href="https://github.com/mff-uk/intlib">
		Github project site</a>, master branch, folder "module/DPU_template"), 
		from which you may derive your DPU implementation. 
		You may start by copying the "module/DPU_template" folder and opening 
		it in, e.g., Netbeans. You can also be inspired by the existing core DPU 
		implementations in the folder "module". </div>
      
		<div> The DPU template project contains 4 important files, which are typically 
		needed when new DPU is created. For each file, we explain in the 
		following sections its purpose and list the mandatory and optional 
		changes (called TODOs) that requires your attention.</div>
        <div>In brief, when creating new DPU, you have to:
        <ul>
        	<li>Adjust pom.xml containing basic metadata about the 
        		DPU project and definitions of the project's dependencies needed for building the ODSGi bundle</li>
        	<li>Define configuration object which holds configuration of the DPU</li>
        	<li>Define the configuration dialog, which may be used by users 
        		of your DPU to set up the configuration object of your DPU
        	<li>Implement the main class of the DPU together with a method which is executed when the pipeline with the DPU instance is executed- 
        		it contains the main functionality of the DPU; the 
        		functionality may be parametrized by the configuration object previously set in the coniguration dialog</li>
        </ul> </div>

		<h3>pom.xml</h3>
		<div>The pom.xml file contains Maven configuration. 
		TODOs in the file have assigned number to make it easy for you to follow them.
		In next few lines we go through all of them and give brief comment 
		to each of them:
		<ul>
			<li><b>TODO 1. module_name: </b>
				The Maven's artifact's ID should be provided here. Maven uses 
				this name to identify the output module (DPU bundle) filename.This 
				value should contains only a-z, A-Z, 0-9 and _ as whitespace. </li>				
			<li><b>TODO 2. DPU version: </b> In most common scenarios you can 
				leave the default value here. This value is stored in manifest.mf 
				file as "version of DPU". It correspond with Bundle-Version 
				in manifest.mf. </li>
			<li><b>TODO 3. DPU description: </b> DPU's description is visible 
				to the users. Provide all necessary information about your 
				intended DPU usage here. Provide contact details on the author
				 of the DPU.</li>
			<li><b>TODO 4. DPU package: </b> Specify the root (longest common) 
				package in which the main class of the bundle is. If you use just one package, use it's name.</li>
			<li><b>TODO 5. DPU's 
				<span class="module_name">main_class_name</span>: </b> 
				Fill the DPU main class name. The main class must be placed in 
				package specified in the previous step. Main class is the class which is called when DPU should be executed by ODCleanStore  </li>
			<li> <b>TODO 6. Dependencies</b> Add your 
				project dependencies here. See the included examples 
				for inspiration. Youcan either set up a dependency pointing to certain Maven artifact or you may set up a local repository residing on your local disc if you do not have access to any maven repository where you can upload the dependencies you requires and are not available on public maven repositories</li>
		</ul>
		<span class="warn"> Do not add dependencies elsewhere as they may not 
		be visible to the Maven.</span> </div>

		<h3>DPUTemplate.java</h3> <div>
		The DPU's main class. The name of the class and file must be 
		the same as <span class="module_name">main_class_name</span> in pom.xml. Thus, 
		rename the file and class in it according to 
		<span class="module_name">main_class_name</span>.As in pom.xml, the
		template file contains "TODOs", places which requires your attention:
		<ul>
			<li><b>TODO 1.</b> Change the implemented interface of the DPU, available choices: 
			<ul>
				<li><b>Extract</b> - Use if you implement new Extractor</li>
				<li><b>Transform</b> - Use if you implement new Transformer </li>
				<li><b>Load</b> - Use if you implement new Loader</li>
			</ul> 
			Each of these interfaces contains unique method that has to be 
			implemented. </li>
			<li><b>TODO 2.</b> Based on implemented interface (selected in TODO 1.) you have to provide implementation
			of one corresponding method required by that interface:
			<ul>
				<li><b>public extract(ExtractContext context)</b> for 
					<b>Extrac</b></li>				  			
				<li><b>public void transform(TransformContext context)</b> 
					for <b>Transfor</b></li>
				<li><b>public void load(LoadContext context)</b> for 
					<b>Load</b></li>
			  	</ul> 
			  	In this method the functionality of the DPU should be 
			  	implemented. All important data needed is passed to the 
			  	method as <a href="theory.html#context">Context</a>.
				</li>
			</ul>
			<p>The sample
			implementation of the main method extract/transform/load for each DPU type follows. </p>
			
            Sample transform() method for simple SPARQL transformer executing 
            the given SPARQL queries over the input data unit and producing corresponding output data unit:
<div class="code"> <pre> <code>
<span class="comment">// transform method which has to be implemented by DPU - transformer</span>
public void transform(TransformContext context) throws TransformException, DataUnitCreateException {
    <span class="comment">// get first input as RDFDataRepository</span>
    RDFDataUnit intputDataUnit = RDFDataUnitList.create(context).getFirst();
    <span class="comment">// create output data unit with name "output" </span>
    RDFDataUnit outputDataUnit = 
                    (RDFDataUnit) context.addOutputDataUnit(DataUnitType.RDF, "output");
    <span class="comment">// query to be executed (obtained from the dialog) </span>            
    String updateQuery = config.getQuery();
    <span class="comment">// copies all data from input RDFDataRepository to 
    	output RDFDataRepository and transforms </span>
    intputDataUnit.copyAllDataToTargetDataUnit(outputDataUnit);
    outputDataUnit.transform(updateQuery);
}
</code> </pre> </div>
			Simple extract() method for extracting data from RDF file to be further processed by the pipeline (next DPU on the pipeline):
<div class="code"> <pre> <code>			
public void extract(ExtractContext context)
	throws ExtractException,
		DataUnitCreateException {
	<span class="comment">// create output</span>
	RDFDataUnit outputDataUnit = (RDFDataUnit) context
			.addOutputDataUnit(DataUnitType.RDF, "output");
	<span class="comment">// prepare configuration</span>
	File file = new File(config.Path);
	<span class="comment">// load data from file into DataUnit</span>
	try {
		outputDataUnit.addTriplesfromFile(file);
	} catch (RDFException e) {
		throw new ExtractException(e.getMessage(), e);
	}
}			
		</code> </pre> </div>
			Simple load() method for loading data at the end of the pipeline to file.
<div class="code"> <pre> <code>			
public void load(LoadContext context)
		throws LoadException,
			DataUnitException {
	<span class="comment">// get first DataUnit, the other we simply ignore</span>
	RDFDataRUnit dataUnit = RDFDataUnitList.create(context).getFirst();
	<span class="comment">// prepare configuration</span>
	final String directoryPath = config.DirectoryPath;
	final String fileName = config.FileName;
	final RDFFormatType formatType = config.RDFFileFormat;
	final boolean isNameUnique = true;
	final boolean canFileOverwritte = true;
	<span class="comment">// load data from DataUnit into file</span>
	try {
		dataUnit.saveTriplesToFile(directoryPath, fileName, formatType,
				canFileOverwritte, isNameUnique);
	} catch (RDFException | CannotOverwriteFileException ex) {
		throw new LoadException(ex);
	}
}			
		</code> </pre> </div>			
		</div>
		
		
		
		<h3>DPUTemplateConfig.java</h3>	<div>
                                      
		This file contains template for DPU's configuration. 
		It represents an object holding configuration needed by the DPU. 
		The class must implement interface 
<div class="code"> <pre> <code> 
cz.cuni.xrg.intlib.commons.configuration.DPUConfigObject
</code> </pre> </div> 
 
		DPUTemplateConfig class may be accessed from DPUTemplate class through the attribute
		<span class="inCode">config</span>. DPUTemplateConfig class requires
		implementation of the validation method. </div>
                
		
		<h3>DPUTemplateDialog.java</h3>	<div>
		This file contains implementation of the DPU's configuration dialog, which uses DPUTemplateConfig.java to persist the configuration from the dialog. 
		The DPU's configuration dialog is implemented as a
		<a href="www.vaadin.com">Vaadin</a> component. The dialog
		class must extends abstract class
<div class="code"> <pre> <code>
cz.cuni.xrg.intlib.commons.module.dialog.BaseConfigDialog&lt;Config&gt;
</code> </pre> </div>
		</div>
			
			
			
	
			
			
				
		
        
		
		
		
		
		
		
		
		
		<h3 id="createBundle">Creating the DPU Bundle</h3>
	DPUs are packed in the form of <a href="#osgi">OSGi</a> bundles. OSGi bundle is a JAR archive with special metadata in the manifest file. 
	DPU bundles are built using maven by running 
        
        <div class="maven-cmd"> <pre> <code>
mvn install
</code> </pre> </div>

on the folder where the pom.xml file is. 
    
	Such command will build and install the OSGI bundle. When building the bundle, the OSGi metadata and the dependencies specified 
	in pom.xml with "compile" scope are automatically added to the output bundle 
	file. However the transitive dependencies are not embeded, used packages from those transitive dependencies are listed in 
	Import-Package list and must be provided by the external environment. 
				
	
	If the external environment (ODCleanStore) cannot provide such dependencies as it is, one of the following steps must be taken:  
	<ol>
		<!--<li>Set <code>embed.transitive</code> property to <code>true</code> - add 
		&lt;embed.transitive&gt;false&lt;/embed.transitive&gt; to pom.xml of the DPU project into
		&lt;properties&gt; element. As a result, the transitive dependencies will be incorporated to the generated bundle as direct dependencies and  these dependencies will not occur as dependencies to be resolved. 
		</li> -->
		<li>Add manually the transitive dependency into pom.xml of the DPU project as a new &lt;dependency&gt; element. As a result, the transitive dependencies will be incorporated to the generated bundle as direct dependencies and these dependencies will not occur as dependencies "to be resolved".</li>
		<li>Create an extra bundle that would be loaded as a library and placed to "module.path/lib", where module.path is the configuration option in config.properties. Such bundle will provide the required packages. Such choice is useful when the dependencies are shared by more DPU modules. See <a href="#bundleLibrary">this section</a> for details how to create such bundle with dependencies which may be used by more DPU modules. </li>
	</ol>
        
	It may be important to mention, that you can use 
	as many external resources as you look to cover all the required packages. But keep in 
	mind that the external resources can also itself have dependencies. These must be also satisfied. 
        

<span class="warn">Do not create JAR file without Maven. This may result into JAR archive that may not work properly because it is not a valid OSGi bundle. </span>

	
	<h4 id="bundleLibrary">Create library bundle from existing jar files</h4>
	This section is relevant only if you selected option 2 in the previous choice. 
        Here we describe how the OSGI bundle can be created from existing jar
	files. Once bundle is created it can be copied into  "module.path/lib"
	directory. From there every bundle is automatically loaded into ODCleanStore
	on it's start. 
	<h5>Eclipse</h5>
	<ul>
		<li>Select <i>File, New, Other</i>.	</li>
		<li><Then in <i>New project</i> dialog,  select
			<i>Plugin from Existing JAR files</i> and click on <i>Next</i></li>
		<li> Now you can select existing jar files.
			These jar files will be used to create an OSGI bundle.</li>
		<li> You can also select jar files that are
			used as a libraries in existing projects. When you select all jar
			files click on <i>Next</i> to continue.</li>
		<li> Now you have to specify <i>Plug-in</i> <i>Name</i>,
			<i>Id</i> and set check boxes according to image. Then click <i>Finish</i>
			to create project.</li>
		<li> Now you can inspect project settings. On the right side of 
			<i>dependency</i> tab you can see list of Import packages. 
			This list specify packages which the OSGi bundle requires to import. 
			These packages must be provided by other bundles or host application
			otherwise your new bundle cannot be resolved and used.</li>
		<li> The last step is to export the bundle
			project. To do this, select <i>File, Export</i>. In <i>Export
				dialog</i>, select <i>Deployable plug-ins and fragments</i> and click on
			<i>Next</i>.</li>
		<li> Then select project end finish the	export.</li>
	</ul>	
		
		
		


<h3>Deploying the DPU bundle to ODCleanStore web application</h3>
		The created bundle (DPU jar file) can be loaded to the ODCleanStore web application on the menu item "DPU Templates", button "Create DPU Template".










	
    
		
		
		
	</body>
</html>
 

